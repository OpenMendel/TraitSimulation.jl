var documenterSearchIndex = {"docs":
[{"location":"#Trait-Simulation-Tutorial-1","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"","category":"section"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"Authors: Sarah Ji, Janet Sinsheimer, Kenneth Lange","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"CurrentModule = TraitSimulation","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"Modules = [TraitSimulation]","category":"page"},{"location":"#TraitSimulation.BernoulliResponse","page":"Trait Simulation Tutorial","title":"TraitSimulation.BernoulliResponse","text":"BernoulliResponse Bernoulli distributed TRAITS, with location.\n\n\n\n\n\n","category":"type"},{"location":"#TraitSimulation.BinomialResponse","page":"Trait Simulation Tutorial","title":"TraitSimulation.BinomialResponse","text":"BinomialResponse Binomial distributed TRAITS, with the number of trials.\n\n\n\n\n\n","category":"type"},{"location":"#TraitSimulation.GLMTrait","page":"Trait Simulation Tutorial","title":"TraitSimulation.GLMTrait","text":"GLMTrait GLMTrait object is one of the two model framework objects. Stores information about the simulation of a single trait, under the Generalized Linear Model Framework.\n\n\n\n\n\n","category":"type"},{"location":"#TraitSimulation.GammaResponse","page":"Trait Simulation Tutorial","title":"TraitSimulation.GammaResponse","text":"GammaResponse Gamma distributed TRAITS, with shape parameter.\n\n\n\n\n\n","category":"type"},{"location":"#TraitSimulation.InverseGaussianResponse","page":"Trait Simulation Tutorial","title":"TraitSimulation.InverseGaussianResponse","text":"InverseGaussianResponse Inverse Gaussian distributed TRAITS, with shape parameter.\n\n\n\n\n\n","category":"type"},{"location":"#TraitSimulation.LMMTrait","page":"Trait Simulation Tutorial","title":"TraitSimulation.LMMTrait","text":"LMMTrait LMMTrait object is one of the two model framework objects. Stores information about the simulation of multiple traits, under the Linear Mixed Model Framework.\n\n\n\n\n\n","category":"type"},{"location":"#TraitSimulation.NormalResponse","page":"Trait Simulation Tutorial","title":"TraitSimulation.NormalResponse","text":"NormalResponse Normally distributed TRAITS, with scale.\n\n\n\n\n\n","category":"type"},{"location":"#TraitSimulation.PoissonResponse","page":"Trait Simulation Tutorial","title":"TraitSimulation.PoissonResponse","text":"PoissonResponse Poisson distributed TRAITS, with location parameter. \n\n\n\n\n\n","category":"type"},{"location":"#TraitSimulation.TResponse","page":"Trait Simulation Tutorial","title":"TraitSimulation.TResponse","text":"TResponse STUDENT-T distributed TRAITS, T distribution with v degrees of freedom \n\n\n\n\n\n","category":"type"},{"location":"#TraitSimulation.VarianceComponent","page":"Trait Simulation Tutorial","title":"TraitSimulation.VarianceComponent","text":"VarianceComponent this VarianceComponent type stores A, B , CholA and CholB so we don't have to compute the cholesky decomposition inside the loop.\n\n\n\n\n\n","category":"type"},{"location":"#TraitSimulation.WeibullResponse","page":"Trait Simulation Tutorial","title":"TraitSimulation.WeibullResponse","text":"WeibullResponse Weibull distributed TRAITS, with shape parameter. \n\n\n\n\n\n","category":"type"},{"location":"#TraitSimulation.Aggregate_VarianceComponents!-Tuple{Any,Any,Array{VarianceComponent,1}}","page":"Trait Simulation Tutorial","title":"TraitSimulation.Aggregate_VarianceComponents!","text":"AggregateVarianceComponents(z, totalvariance, vc) Update the simulated trait with the effect of each variance component. We note the exclamation is to indicate this function will mutate or override the values that its given.\n\n\n\n\n\n","category":"method"},{"location":"#TraitSimulation.LMM_trait_simulation-Tuple{Any,Array{VarianceComponent,1}}","page":"Trait Simulation Tutorial","title":"TraitSimulation.LMM_trait_simulation","text":"LMMtraitsimulation(mu, vc::Vector{VarianceComponent}) For a vector of Variance Component objects, without computing mean from dataframe and formulas i.e given an evaluated matrix of means, simulate from LMM.\n\n\n\n\n\n","category":"method"},{"location":"#TraitSimulation.LMM_trait_simulation-Tuple{Any,VarianceComponent}","page":"Trait Simulation Tutorial","title":"TraitSimulation.LMM_trait_simulation","text":"LMMtraitsimulation(mu, vc::VarianceComponent) For a single Variance Component object, without computing mean from dataframe and formulas i.e given an evaluated matrix of means, simulate from LMM.\n\n\n\n\n\n","category":"method"},{"location":"#TraitSimulation.LMM_trait_simulation-Union{Tuple{T}, Tuple{Any,Array{T,2}}} where T","page":"Trait Simulation Tutorial","title":"TraitSimulation.LMM_trait_simulation","text":"LMMtraitsimulation single LMM trait with given evaluated matrix of Variance components\n\n\n\n\n\n","category":"method"},{"location":"#TraitSimulation.SimulateMVN!-Tuple{Any,VarianceComponent}","page":"Trait Simulation Tutorial","title":"TraitSimulation.SimulateMVN!","text":"SimulateMVN!(z, vc) SimulateMVN(npeople, ntraits, vc::VarianceComponent) For a single Variance Component, algorithm that will transform standard normal distribution. SimulateMVN allows us to preallocate npeople by ntraits and rewrite over this matrix to save memory allocation.\n\n\n\n\n\n","category":"method"},{"location":"#TraitSimulation.append_terms!-Tuple{Any,Any}","page":"Trait Simulation Tutorial","title":"TraitSimulation.append_terms!","text":"append_terms Allows us to append terms to create a VarianceComponent type\n\n\n\n\n\n","category":"method"},{"location":"#TraitSimulation.mean_formula-Tuple{String,DataFrames.DataFrame}","page":"Trait Simulation Tutorial","title":"TraitSimulation.mean_formula","text":"mean_formula(user_formula_string, df)\n\nConstruction of the evaluated mean vector, given user formula string and named dataframe of covariates. This function is the main mean_formula function.\n\nThis function makes calls to findvariables, searchvariables. \n\n\n\n\n\n","category":"method"},{"location":"#TraitSimulation.simulate-Tuple{GLMTrait}","page":"Trait Simulation Tutorial","title":"TraitSimulation.simulate","text":"simulate(trait, n_reps)\n\nthis for simulating a single GLM trait, n_reps times. \n\n\n\n\n\n","category":"method"},{"location":"#TraitSimulation.simulate-Tuple{LMMTrait}","page":"Trait Simulation Tutorial","title":"TraitSimulation.simulate","text":"simulate(trait, nreps)\n\nthis for simulating multiple LMMtraits, n_reps times. \n\n\n\n\n\n","category":"method"},{"location":"#TraitSimulation.vcobjtuple-Tuple{Array{VarianceComponent,1}}","page":"Trait Simulation Tutorial","title":"TraitSimulation.vcobjtuple","text":"vcobjectuple(vcobject) This function creates a tuple of Variance Components, given a vector of variancecomponent objects to be compatible with VarianceComponentModels.jl\n\n\n\n\n\n","category":"method"},{"location":"#TraitSimulation.ResponseDistribution","page":"Trait Simulation Tutorial","title":"TraitSimulation.ResponseDistribution","text":"ResponseDistribution This super type of all response distribution types\n\n\n\n\n\n","category":"type"},{"location":"#TraitSimulation.find_variables-Tuple{Any}","page":"Trait Simulation Tutorial","title":"TraitSimulation.find_variables","text":"findvariables(x) Find and return the variable names in the expression x. This function is called in the main function meanformula. \n\n\n\n\n\n","category":"method"},{"location":"#TraitSimulation.search_variables!-Tuple{Expr,Symbol}","page":"Trait Simulation Tutorial","title":"TraitSimulation.search_variables!","text":"searchvariables(x, var) Search the expression x for the variable name in var, and then create the julia interpretable expression. We extend this function to allow for recursion on the variable vars... This function is called in the main function meanformula. \n\n\n\n\n\n","category":"method"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"In this notebook we show how to use the TraitSimulation.jl package to simulate traits from genotype data from unrelateds or families with user-specified Generalized Linear Models (GLMs) or Linear Mixed Models (LMMs), respectively. For simulating under either GLM or LMMs, the user can specify the number of repitions for each simulation model. By default, the simulation will return the result of a single simulation. ","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"The data we will be using are from the Mendel version 16[1] sample files. The data are described in examples under Option 28e in the Mendel Version 16 Manual Section 28.1,  page 279. It consists of simulated data where the two traits of interest have one contributing SNP and a sex effect.","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"We use the OpenMendel package SnpArrays.jl to read in the PLINK formatted SNP data. In example 1, we simulate generalized linear models assuming that everyone is unrelated. So in example 1,  the only data used from option 28e is the genotype for a specific locus in the snp file and the sex of the individual. The pedigree structure and relationship matrix are irrelevant.   In example 2 we simulate data under a linear mixed model so that we can model residual dependency among individuals.  In example 2b, we use the same parameters as were used in Mendel Option 28e with the simulation parameters for Trait1 and Trait2 in Ped28e.out as shown below.","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"In both examples, you can specify your own arbitrary fixed effect sizes, variance components and simulation parameters as desired. You can also specify the number of replicates for each Trait simulation in the simulate function.","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"In the mathbfGenerating mathbfEffect mathbfSizes Section of Example 2), we show how the user can generate effect sizes that depend on the minor allele frequencies from the chisquare distribution. To aid the user when they wish to include a large number of loci in the model, we created a function that automatically writes out the mean components for simulation.","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"textbfAt the end of Examples 1 and 3","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":", we demo how to textbfwrite the results of the simulation to a file on your own machine.","category":"page"},{"location":"#Double-check-that-you-are-using-Julia-version-1.0-or-higher-by-checking-the-machine-information-1","page":"Trait Simulation Tutorial","title":"Double check that you are using Julia version 1.0 or higher by checking the machine information","text":"","category":"section"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"versioninfo()","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"Julia Version 1.1.1\nCommit 55e36cc (2019-05-16 04:10 UTC)\nPlatform Info:\n  OS: macOS (x86_64-apple-darwin15.6.0)\n  CPU: Intel(R) Core(TM) i7-7700HQ CPU @ 2.80GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-6.0.1 (ORCJIT, skylake)","category":"page"},{"location":"#Add-any-missing-packages-needed-for-this-tutorial:-1","page":"Trait Simulation Tutorial","title":"Add any missing packages needed for this tutorial:","text":"","category":"section"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"Note: For demonstration purposes, the generation of this Jupyter Notebook requires the use of the following registered packages: DataFrames.jl, SnpArrays.jl, StatsModels.jl, Random.jl, DelimitedFiles.jl, StatsBase.jl, and StatsFuns.jl. ","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"If it is your first time using these registered packages, you will first have to add the registered packages: DataFrames, SnpArrays, StatsModels, Random, LinearAlgebra, DelimitedFiles, Random, StatsBase by running the following code chunk in Julia's package manager:","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"pkg> add DataFrames\npkg> add SnpArrays\n...\npkg> add StatsFuns","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"You can also use the package manager to add the TraitSimulation.jl package by running the following link: </br>","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"pkg> add \"https://github.com/sarah-ji/TraitSimulation.jl\"","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"Only after all of the necessary packages have been added, load them into your working environment with the using command:","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"using DataFrames, SnpArrays, StatsModels, Random, LinearAlgebra, DelimitedFiles, StatsBase, TraitSimulation, StatsFuns\nusing CSV","category":"page"},{"location":"#Reproducibility-1","page":"Trait Simulation Tutorial","title":"Reproducibility","text":"","category":"section"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"For reproducibility, we set a random seed using the Random.jl package for each simulation using Random.seed!(1234).  If you wish to end up with different data, you will need to comment out these commands or use another value in Random.seed!().","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"Random.seed!(1234);","category":"page"},{"location":"#The-notebook-is-organized-as-follows:-1","page":"Trait Simulation Tutorial","title":"The notebook is organized as follows:","text":"","category":"section"},{"location":"#Example-1:-Generalized-Linear-Model-1","page":"Trait Simulation Tutorial","title":"Example 1: Generalized Linear Model","text":"","category":"section"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"In this example we show how to generate multiple traits from GLM's with a genetic variant in the fixed effects, but no residual familial correlation.","category":"page"},{"location":"#Single-Trait:-1","page":"Trait Simulation Tutorial","title":"Single Trait:","text":"","category":"section"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"Y âŒ N(mu sigma^2)","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"In example (1a) we simulate a textbfSINGLE INDEPENDENT NORMAL TRAIT, with simulation parameters: mu = 20 + 3*sex - 15*locus, sigma^2 = 2. By default, without specifying a number of replicates for the user specified GLM (like this example), the simulate function returns a single simulated trait.","category":"page"},{"location":"#Example-2:-Linear-Mixed-Model-1","page":"Trait Simulation Tutorial","title":"Example 2: Linear Mixed Model","text":"","category":"section"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"In this example we show how to generate data so that the related individuals have correlated trait values even after we account for the effect of a snp, a combination of snps or other fixed effects.","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"For convenience we use the common assumption that the residual covariance among two relatives can be captured by the additive genetic variance times twice the kinship coefficient. However, if you like you can specify your own variance components and their design matrices as long as they are positive semi definite using the @vc macro demonstrated in this example. We run this simulation 1000 times, and store the simulation results in a vector of DataFrames.","category":"page"},{"location":"#(a)-Multiple-Independent-Traits:-1","page":"Trait Simulation Tutorial","title":"(a) Multiple Independent Traits:","text":"","category":"section"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"Y âŒ N(mu 4* 2GRM + 2I n_reps = 10)","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"In example (2a) we simulate textbfMULTIPLE 2 INDEPENDENT TRAITS CONTROLLING FOR FAMILY STRUCTURE, with the corresponding Mendel Example 28e Simulation parameters, location : mu = 40 + 3*sex - 15*locus, scale : V = 4* 2GRM + 2I We run this simulation 1000 times.","category":"page"},{"location":"#(b)-Multiple-Correlated-Traits:-(Mendel-Example-28e-Simulation)-1","page":"Trait Simulation Tutorial","title":"(b) Multiple Correlated Traits: (Mendel Example 28e Simulation)","text":"","category":"section"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"$","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"Y =  \\begin{bmatrix} Y{1}\\\nY{2} \\end{bmatrix}, Y{1} \\not!\\perp!!!\\perp Y{2} $","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"Y sim N(mathbfmuSigma  = V_a otimes (2GRM) + V_e otimes I_n) ","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"\nmathbfmu = beginbmatrix\nmu_1 \nmu_2 \nendbmatrix\n= beginbmatrix\n40 + 3(sex) - 15(locus)\n20 + 2(sex) - 15(locus)\nendbmatrix  V_a = beginbmatrix\n4  1\n1  4\nendbmatrix  V_e \n= beginbmatrix\n2  0\n0  2\nendbmatrix\n\n\n\nWe simulate textbfTWO CORRELATED TRAITS CONTROLLING FOR FAMILY STRUCTURE with simulation parameters location = mu and scale = Sigma By default without specifying a number of replicates for the user specified LMM (like this example) the simulate function returns a single set of simulated traits\n\n\n Example 3 Rare Variant Linear Mixed Model \n\nThis example is meant to simulate data in a scenario in which a number of rare mutations in a single gene can change a trait value  In this example we model the residual variation among relatives with the additive genetic variance component and we include 20 rare variants in the mean portion of the model defined as loci with minor allele frequencies greater than 0002 but less than 002  In practice rare variants have smaller minor allele frequencies but we are limited in this tutorial by the relatively small size of the data set Note also that our modeling these effects as part of the mean is not meant to imply that the best way to detect them would be a standard association analysis Instead we recommend a burden or SKAT test br\n\nSpecifically we are generating a single normal trait controlling for family structure with residual heritabiity of 67 and effect sizes for the variants generated as a function of the minor allele frequencies The rarer the variant the greater its effect size\n\nWe run this simulation 1000 times and store the simulation results in a vector of DataFrames At the end of this example we write the results of the first of the 1000 replicates to a file on your own machine\n\n Y âŒ N(mu_rare20 4* 2GRM + 2I n_reps = 1000)\n\n\n Reading the Mendel 28a data using SnpArrays\n\nFirst use SnpArraysjl to read in the genotype data The value 212 is the number of individuals in the genotype data set \n\n\n\njulia\nsnpdata = SnpArray(traitsim28ebed 212)\n\n\n\n\n\n    212Ã253141 SnpArray\n     0x03  0x03  0x00  0x03  0x03  0x03     0x02  0x02  0x00  0x00  0x03  0x00\n     0x03  0x03  0x00  0x02  0x02  0x03     0x00  0x03  0x00  0x00  0x03  0x00\n     0x03  0x03  0x00  0x03  0x03  0x03     0x03  0x02  0x00  0x00  0x03  0x00\n     0x03  0x03  0x00  0x03  0x03  0x03     0x02  0x03  0x00  0x00  0x03  0x00\n     0x03  0x03  0x00  0x03  0x03  0x03     0x00  0x03  0x00  0x00  0x03  0x00\n     0x03  0x03  0x00  0x03  0x03  0x03     0x00  0x00  0x00  0x00  0x00  0x03\n     0x03  0x02  0x00  0x03  0x03  0x03     0x02  0x03  0x00  0x03  0x00  0x03\n     0x03  0x03  0x00  0x03  0x03  0x03     0x02  0x03  0x00  0x03  0x00  0x03\n     0x03  0x02  0x00  0x03  0x03  0x03     0x02  0x02  0x00  0x02  0x00  0x03\n     0x03  0x02  0x00  0x03  0x03  0x03     0x03  0x03  0x00  0x03  0x00  0x03\n     0x03  0x02  0x00  0x03  0x03  0x03     0x00  0x02  0x00  0x02  0x00  0x03\n     0x03  0x03  0x00  0x03  0x03  0x03     0x00  0x02  0x00  0x02  0x00  0x03\n     0x03  0x02  0x00  0x03  0x03  0x03     0x02  0x02  0x00  0x02  0x00  0x03\n     0x03  0x03  0x00  0x03  0x03  0x03     0x00  0x03  0x00  0x00  0x03  0x00\n     0x03  0x03  0x00  0x03  0x03  0x03     0x00  0x03  0x00  0x02  0x02  0x02\n     0x03  0x03  0x00  0x03  0x03  0x03     0x00  0x02  0x00  0x00  0x03  0x00\n     0x03  0x02  0x00  0x02  0x02  0x03     0x02  0x03  0x00  0x03  0x00  0x03\n     0x03  0x03  0x00  0x02  0x02  0x03     0x02  0x03  0x00  0x00  0x03  0x00\n     0x03  0x03  0x00  0x03  0x03  0x03     0x02  0x03  0x00  0x02  0x02  0x00\n     0x03  0x03  0x00  0x02  0x02  0x03     0x02  0x03  0x00  0x00  0x02  0x02\n     0x03  0x03  0x00  0x03  0x03  0x03     0x00  0x03  0x00  0x00  0x03  0x00\n     0x03  0x02  0x00  0x03  0x03  0x03     0x02  0x03  0x00  0x00  0x02  0x02\n     0x03  0x03  0x00  0x03  0x03  0x03     0x00  0x03  0x00  0x00  0x03  0x00\n     0x03  0x03  0x00  0x03  0x03  0x03     0x02  0x03  0x00  0x00  0x03  0x00\n     0x03  0x03  0x00  0x03  0x03  0x03     0x00  0x03  0x00  0x02  0x02  0x02\n\n\n\nThe first line gives the size of the matrix 212 individuals by 253141 the number of loci\n\nThe binary codes correspond to genotypes A1A1=0x00 missing=0x01 A1A2=0x02 and A2A2=0x03\n\nSnpArrays is a very useful utility and can do a lot more than just read in the data More information about all the functionality of SnpArrays can be found at\nhttpsopenmendelgithubioSnpArraysjllatest\n\nStore the FamID and PersonID of Individuals in Mendel 28e data\n\n\njulia\nfamfile = readdlm(traitsim28efam )\nFam_Person_id = DataFrame(FamID = famfile 1 PID = famfile 2)\n\n\n\nNote Because later we will want to compare our results to Mendel 28e results  we subset Traits_Mendel28e \n\n\njulia\nTraits_Mendel28e = DataFrame(Trait1 = famfile 7 Trait2 = famfile 8)\n\n\n\nTransform sex variable from MF to 1-1 as is done in the older version of Mendel  If you prefer you can use the more common convention of making one of the sexes the reference sex (coding it as zero) and make the other sex have the value 1 but then you will have to work a little harder to compare the results to the older version of Mendel \n\n\njulia\nsex = map(x - strip(x) == F  -10  10 famfile 5)  note julias ternary operator \n\n\n    212-element ArrayFloat641\n     -10\n     -10\n      10\n      10\n     -10\n     -10\n      10\n      10\n     -10\n      10\n     -10\n      10\n     -10\n      10\n      10\n      10\n     -10\n      10\n      10\n      10\n      10\n      10\n      10\n      10\n      10\n\n\n\n Names of Variants\n\nWe will use snp rs10412915 as a covariate in our model  We want to find the index of this causal locus in the snp_definition file and then subset that locus from the genetic marker data above \nWe first subset the names of all the loci into a vector called snpid\n\n\njulia\nsnpdef28_1 = readdlm(traitsim28ebim Any header = false)\nsnpid = map(x - strip(string(x)) snpdef28_1 1)  strip mining in the data \n\n\n\n\n\n    253141-element ArraySubStringString1\n     rs3020701  \n     rs56343121 \n     rs143501051\n     rs56182540 \n     rs7260412  \n     rs11669393 \n     rs181646587\n     rs8106297  \n     rs8106302  \n     rs183568620\n     rs186451972\n     rs189699222\n     rs182902214        \n     rs188169422\n     rs144587467\n     rs139879509\n     rs143250448\n     rs145384750\n     rs149215836\n     rs139221927\n     rs181848453\n     rs138318162\n     rs186913222\n     rs141816674\n     rs150801216\n\n\n\nWe next need to find the position of the snp rs10412915  If you wish to use another snp as the causal locus just change the rs number to another one that is found in the available genotype data for example rs186913222\n\n\njulia\nind_rs10412915 = findall(x - x == rs10412915 snpid)1\n\n\n    236074\n\n\n\nWe see that rs10412915 is the 236074th locus in the dataset\n\nLets create a design matrix for the model that includes sex and locus rs10412915\n\n\njulia\nlocus = convert(VectorFloat64 view(snpdata ind_rs10412915))\nX = DataFrame(sex = sex locus = locus)\n\n\n Example 1 Generalized Linear Model\n\nThis example simulates a case where three snps have fixed effects on the trait Any apparent genetic correlation between relatives for the trait is due to the effect of these snps so once these effects of these snps are modelled there should be no residual correlation among relatives Note that by default individuals with missing genotype values will have missing phenotype values unless the user specifies the argument impute = true in the convert function above\nBe sure to change Randomseed(1234) to something else (or comment out) if you want to generate a new data set \n\n\n Example 1a Single Trait\nY âŒ N(mu sigma^2)","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"In example (1a) we simulate a textbfSINGLE INDEPENDENT NORMAL TRAIT, with simulation parameters: mu = 20 + 3*sex - 15*locus, sigma^2 = 2","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"mean_formula = \"20 + 3(sex) - 1.5(locus)\"\nGLM_trait_model = GLMTrait(mean_formula, X, NormalResponse(2), IdentityLink())\nSimulated_GLM_trait = simulate(GLM_trait_model)","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"describe(Simulated_GLM_trait, stats = [:mean, :std, :min, :q25, :median, :q75, :max, :eltype])","category":"page"},{"location":"#Saving-Simulation-Results-to-Local-Machine-1","page":"Trait Simulation Tutorial","title":"Saving Simulation Results to Local Machine","text":"","category":"section"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"Write the newly simulated trait into a comma separated (csv) file for later use. Note that the user can specify the separator to '\\t' for tab separated, or another separator of choice. ","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"Here we output the simulated trait and covariates for each of the 212 individuals, labeled by their pedigree ID and person ID.","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"Trait1_GLM = hcat(Fam_Person_id, Simulated_GLM_trait, X)","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"#cd(\"/Users\") #change to home directory\nCSV.write(\"Trait1_GLM.csv\", Trait1_GLM)","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"\"Trait1_GLM.csv\"","category":"page"},{"location":"#Example-2:-Linear-Mixed-Model-(with-additive-genetic-variance-component).-1","page":"Trait Simulation Tutorial","title":"Example 2: Linear Mixed Model (with additive genetic variance component).","text":"","category":"section"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"Examples 2a simulates a single trait, while Example 2b simulates two correlated traits.","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"Note you can scale the function to simulate the trait multiple times by specifying the argument, n_reps.  Also, you can extend the model in Example 2b to include more than 2 variance components using the @vc macro.","category":"page"},{"location":"#The-Variance-Covariance-Matrix-1","page":"Trait Simulation Tutorial","title":"The Variance Covariance Matrix","text":"","category":"section"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"Recall : E(mathbfGRM) = Phi","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"We use the SnpArrays.jl package to find an estimate of the Kinship (Phi), the Genetic Relationship Matrix (GRM). ","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"We will use the same values of textbfGRM V_a and V_e in the bivariate covariance matrix for both the mixed effect example and for the rare variant example.","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"Note that the residual covariance among two relatives is the additive genetic variance, textbfV_a, times twice the kinship coefficient, Phi. The kinship matrix is derived from the genetic relationship matrix textbfGRM across the common SNPs with minor allele frequency at least 0.05.","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"GRM = grm(snpdata, minmaf = 0.05)","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"212Ã212 Array{Float64,2}:\n  0.498264     0.0080878    0.0164327   âŠ   0.0246825    0.00181856\n  0.0080878    0.498054    -0.0212599      -0.0285927   -0.0226525 \n  0.0164327   -0.0212599    0.499442       -0.0219661   -0.00748536\n  0.253627    -0.00160532   0.282542        0.00612693  -0.00339125\n  0.126098     0.253365     0.128931       -0.0158446   -0.00633959\n -0.014971    -0.00266073  -0.00243384  âŠ   0.00384757   0.0145936 \n -0.0221357    0.0100492   -0.0107012      -0.0148443   -0.00127783\n -0.01629     -0.00749253  -0.015372       -0.0163305   -0.00258392\n -0.016679     0.00353587  -0.0128844      -0.0332489   -0.00707839\n -0.0176101   -0.00996912  -0.0158473      -0.00675875  -0.0122339 \n -0.0162558    0.00938592   0.0064231   âŠ  -0.00510882   0.0168778 \n -0.0167487    0.00414544  -0.00936538     -0.0134863    0.0020952 \n -0.031148     0.00112387  -0.010794        0.00383105   0.0198635 \n  â®                                     â±   â®                      \n -0.00865735  -0.00335548  -0.0148433   âŠ   0.00806601  -0.0211537 \n  0.00296028   0.0043655   -0.0183683       0.0012496    0.00898193\n -0.0204601   -0.0270898   -0.00194048     -0.0185883   -0.0116621 \n -0.0174561   -0.0128509   -0.0155773      -0.0274183   -0.0063823 \n -0.00170995   0.0154211   -0.00168146     -0.00684865  -0.0067438 \n  0.00718047  -0.00525265  -0.00283975  âŠ   0.0309601    0.0261103 \n -0.0170218   -0.00661916   0.0020924      -0.022858     0.0037451 \n  0.0142551    0.0208073    0.0096287       0.00598877   0.0094809 \n -0.00586031  -0.00733706   0.0339257       0.0109116   -0.0177771 \n  0.00299024  -0.0134027    0.0150825       0.00799507   0.0150077 \n  0.0246825   -0.0285927   -0.0219661   âŠ   0.593999     0.0497083 \n  0.00181856  -0.0226525   -0.00748536      0.0497083    0.491743","category":"page"},{"location":"#Example-2a:-Single-Trait-1","page":"Trait Simulation Tutorial","title":"Example 2a: Single Trait","text":"","category":"section"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"\nY âŒ N(ÎŒ 4* 2GRM + 2I n_reps = 1000)","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"We simulate a Normal Trait controlling for family structure, location = mu = 40 + 3(sex) - 15(locus) and scale =  mathbfV = 2*V_a Phi + V_e I = 4* 2GRM + 2I. ","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"mean_formula = [\"40 + 3(sex) - 1.5(locus)\"]","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"1-element Array{String,1}:\n \"40 + 3(sex) - 1.5(locus)\"","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"I_n = Matrix{Float64}(I, size(GRM));\nLMM_trait_model = LMMTrait(mean_formula, X, 4*(2*GRM) + 2*(I_n))\nSimulated_LMM_Trait = simulate(LMM_trait_model, 1000)","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"Let's look at summary statistics of just the first of the 1000 simulation results.","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"describe(Simulated_LMM_Trait[1], stats = [:mean, :std, :min, :q25, :median, :q75, :max, :eltype])","category":"page"},{"location":"#Example-2b:-Multiple-Correlated-Traits-(Mendel-Example-28e-Simulation)-1","page":"Trait Simulation Tutorial","title":"Example 2b: Multiple Correlated Traits (Mendel Example 28e Simulation)","text":"","category":"section"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"We simulate two correlated Normal Traits controlling for family structure, location = ÎŒ and scale = mathbfSigma.  The corresponding bivariate variance covariance matrix as specified Mendel Option 28e, mathbfÎ, is generated here.","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"\nY âŒ N(ÎŒ mathbfSigma)\n \n\n\nmathbfmu = beginvmatrix\nmu_1 \nmu_2 \nendvmatrix\n= beginvmatrix\n40 + 3(sex) - 15(locus)\n20 + 2(sex) - 15(locus)\nendvmatrix\n\n\n\n\nmathbfSigma  = V_a otimes (2GRM) + V_e otimes I_n\n\n\n\nnbsp FYI To create a trait with different variance components change the elements of mathbfSigma We create the variance component object variance_formula below to simulate our traits in example 2b While this tutorial only uses 2 variance components we make note that the vc macro is designed to handle as many variance components as needed \n\nAs long as each Variance Component is specified correctly we can create a VarianceComponent Julia object for Trait Simulation\n\nnbsp \nExample) Specifying more than 2 variance components (let V_H indicate an additional Household Variance component and V_D indicate a dominance genetic effect) \n\njulia\n    multiple_variance_formula = vc V_A â 2GRM + V_E â I_n + V_D â Î + V_H â H\n\n\nV_E is multiplies a 212 by 212 identity matrix which we creat along with the V_E and V_A matrices \n\n\njulia\nV_A = 4 1 1 4\nV_E = 20 00 00 20\n\n\n\njulia\n vc is a macro that creates a VarianceComponent Type for simulation\nvariance_formula = vc V_A â 2GRM + V_E â I_n\n\n\nThese are the formulas for the fixed effects as specified by Mendel Option 28e\n\n\njulia\nmean_formulas = 40 + 3(sex) - 15(locus) 20 + 2(sex) - 15(locus)\n\n\n\n\n\n    2-element ArrayString1\n     40 + 3(sex) - 15(locus)\n     20 + 2(sex) - 15(locus)\n\n\n\n\njulia\nMultiple_LMM_traits_model = LMMTrait(mean_formulas X variance_formula)\nSimulated_LMM_Traits = simulate(Multiple_LMM_traits_model)\n\n\n\n Summary Statistics of Our Simulated Traits\n\n\njulia\ndescribe(Simulated_LMM_Traits stats = mean std min max eltype)\n\n\n\n\n Summary Statistics of the Original Mendel 28e dataset Traits\n\nNote we want to see similar values from our simulated traits\n\n\njulia\ndescribe(Traits_Mendel28e stats = mean std min max eltype)\n\n\n\n\n Example 3 Rare Variant Linear Mixed Model\n\n\n\nY âŒ N(mu_rare20 4* 2GRM + 2I)\n\n\nIn this example we first subset only the rare SNPs with minor allele frequency greater than 0002 but less than 002 then we simulate traits on 20 of the rare SNPs as fixed effects For this demo the indexing snpidrare_index1240 allows us to subset every other rare snp in the first 40 SNPs to get our list of 20 rare SNPs Change the range and number of SNPs to simulate with more or less SNPs and from different regions of the genome The number 20 is arbitrary and you can use more or less than 20 if you desire by changing the final number You can change the spacing of the snps by changing the second number \nFor example snpidrare_index15500 would give you 100 snps\n\nHere are the 20 SNPs that will be used for trait simulation in this example  \n\nIn this demo we run this simulation 1000 times You can change the number of repitions by changing the second argument in the simulate(rare_20_snp_model 1000) function to any integer\n\n\njulia\n filter out rare SNPS get a subset of uncommon SNPs with 0002  MAF â 002\nminor_allele_frequency = maf(snpdata)\nrare_index = (0002  minor_allele_frequency â 002)\ndata_rare = view(snpdata rare_index)\n\n\n\njulia\nmaf_20_rare_snps = minor_allele_frequencyrare_index1240\nrare_snps_for_simulation = snpidrare_index1240\n\n\n\n\n\n    20-element ArraySubStringString1\n     rs3020701  \n     rs181646587\n     rs182902214\n     rs184527030\n     rs10409990 \n     rs185166611\n     rs181637538\n     rs186213888\n     rs184010370\n     rs11667161 \n     rs188819713\n     rs182378235\n     rs146361744\n     rs190575937\n     rs149949827\n     rs117671630\n     rs149171388\n     rs188520640\n     rs142722885\n     rs146938393\n\n\n\n Generating Effect Sizes (Based on MAF)\n\nIn practice rare SNPs have smaller minor allele frequencies but we are limited in this tutorial by the number of individuals in the data set We use generated effect sizes to evaluate mu_rare20 on the following Dataframe br \n\n\njulia\ngeno_rare_converted = convert(MatrixFloat64 data_rare)\n\n\n\njulia\ngeno_rare20_converted = convert(DataFrame geno_rare_converted 1240)\nnames(geno_rare20_converted Symbol(rare_snps_for_simulation))\n\n\n Chisquared Distribution (df = 1)\n\nFor demonstration purposes we simulate effect sizes from the Chi-squared(df = 1) distribution where we use the minor allele frequency (maf) as x and find f(x) where f is the pdf for the Chi-squared (df = 1) density so that the rarest SNPs have the biggest effect sizes The effect sizes are rounded to the second digit throughout this example Notice there is a random +1 or -1 so that there are effects that both increase and decrease the simulated trait value\n\n\njulia\n Generating Effect Sizes from Chisquared(df = 1) density\nn = length(maf_20_rare_snps)\nchisq_coeff = zeros(n)\n\nfor i in 1n\n    chisq_coeffi = rand(-1 1) * (01  sqrt(maf_20_rare_snpsi * (1 - maf_20_rare_snpsi)))\nend\n\n\nTake a look at the simulated coefficients on the left next to the corresponding minor allele frequency Notice the rarer SNPs have the largest absolute values for their effect sizes\n\n\njulia\nEx3_rare = round(chisq_coeff maf_20_rare_snps digits = 3)\nEx3_rare = DataFrame(Chisq_Coefficient = Ex3_rare 1  MAF_rare = Ex3_rare 2 )\n\n\n\njulia\nsimulated_effectsizes_chisq = Ex3_rare 1\n\n\n\n\n\n    20-element ArrayFloat641\n     -0785\n     -0847\n      1034\n     -0735\n      1034\n     -1459\n      1193\n     -1034\n     -1193\n      2062\n      0847\n      1459\n      2062\n     -1459\n      0735\n      2062\n      2062\n     -2062\n      0735\n     -1459\n\n\n\n Function for Mean Model Expression\n\nIn some cases a large number of variants may be used for simulation Thus in this example we create a function where the user inputs a vector of coefficients and a vector of variants for simulation then the function outputs the mean model expression \n\nThe function FixedEffectTerms creates the proper evaluated expression for the simulation process using the specified vectors of coefficients and snp names The function outputs evaluated_fixed_expression which will be used to estimate the mean effect ÎŒ in our mixed effects model We make use of this function in this example instead of having to write out all 20 of the coefficients and variant locus names\n\n\njulia\nrare_snps_for_simulation\n\n\n\n\n\n    20-element ArraySubStringString1\n     rs3020701  \n     rs181646587\n     rs182902214\n     rs184527030\n     rs10409990 \n     rs185166611\n     rs181637538\n     rs186213888\n     rs184010370\n     rs11667161 \n     rs188819713\n     rs182378235\n     rs146361744\n     rs190575937\n     rs149949827\n     rs117671630\n     rs149171388\n     rs188520640\n     rs142722885\n     rs146938393\n\n\n\n\njulia\nfunction FixedEffectTerms(effectsizesAbstractVecOrMat snpsAbstractVecOrMat)\n  implementation\n    fixed_terms = \nfor i in 1length(simulated_effectsizes_chisq) - 1\nexpression =  +  * string(simulated_effectsizes_chisqi) * ( * rare_snps_for_simulationi * )\n    fixed_terms = fixed_terms * expression\nend\n    return String(fixed_terms)\nend\n\n\n\n\n\n\n    FixedEffectTerms (generic function with 1 method)\n\n\n\nExample 3 Single Trait Rare Variants\n\nWe look at just the first of the 1000 simulation results below\n\n\nY âŒ N(ÎŒ_20raresnps 4* 2GRM + 2I n_reps = 1000)","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"mean_formula_rare = FixedEffectTerms(simulated_effectsizes_chisq, rare_snps_for_simulation);\nrare_20_snp_model = LMMTrait([mean_formula_rare], geno_rare20_converted, 4*(2*GRM) + 2*(I_n))\ntrait_rare_20_snps = simulate(rare_20_snp_model, 1000)[1]","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"Some summary statistics of just the first of the 1000 simulation results.","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"describe(trait_rare_20_snps[1], stats = [:mean, :std, :min, :max, :eltype])","category":"page"},{"location":"#Saving-Simulation-Results-to-Local-Machine-2","page":"Trait Simulation Tutorial","title":"Saving Simulation Results to Local Machine","text":"","category":"section"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"Here we output the simulated trait values and corresponding genotypes for each of the 212 individuals, labeled by their pedigree ID and person ID for the first iteration of the 1000 simulations. ","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"Trait3_rare = hcat(Fam_Person_id, trait_rare_20_snps[1], geno_rare20_converted)","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"In addition, we output the simulation parameters (generated effect sizes and SNP names) used to simulate this trait.","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"Coefficients = DataFrame(Coefficients = simulated_effectsizes_chisq)\nSNPs_rare = DataFrame(SNPs = rare_snps_for_simulation)\nTrait3_rare_sim = hcat(Coefficients, SNPs_rare)","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"#cd(\"/Users\") #change to home directory\nCSV.write(\"Trait3_rare.csv\", Trait3_rare)\nCSV.write(\"Trait3_rare_sim.csv\", Trait3_rare_sim);","category":"page"},{"location":"#Citations:-1","page":"Trait Simulation Tutorial","title":"Citations:","text":"","category":"section"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"[1] Lange K, Papp JC, Sinsheimer JS, Sripracha R, Zhou H, Sobel EM (2013) Mendel: The Swiss army knife of genetic analysis programs. Bioinformatics 29:1568-1570.`","category":"page"},{"location":"#","page":"Trait Simulation Tutorial","title":"Trait Simulation Tutorial","text":"[2] OPENMENDEL: a cooperative programming project for statistical genetics. Hum Genet. 2019 Mar 26. doi: 10.1007/s00439-019-02001-z.","category":"page"}]
}
